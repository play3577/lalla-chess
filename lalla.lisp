;;;; lalla.lisp

(in-package #:lalla)


(defun* (search -> (signed-byte 32)) ((side (signed-byte 32)) (alpha (signed-byte 32)) 
				      (beta (signed-byte 32)) (eval (signed-byte 32)) 
				      (key-lo (signed-byte 32)) (key-hi (signed-byte 32)) 
				      (ep-sqr (signed-byte 32)) (last-to (signed-byte 32)) 
				      (depth (signed-byte 32)))
  (*let ((step-vec (signed-byte 32) 0)
	 (best-score (signed-byte 32) 0)
	 (score (signed-byte 32) 0)
	 (iter-depth (signed-byte 32) 0)
	 (h (signed-byte 32) 0)
	 (i (signed-byte 32) 8)
	 (j (signed-byte 32) 
	    (logand (logxor (* side ep-sqr) key-lo)
		    (- *hash-size* 9)))
	 (skip-sqr (signed-byte 32) 0)
	 (rook-sqr (signed-byte 32) 0)
	 (victim (signed-byte 8) 0)
	 (piece-type (signed-byte 8) 0)
	 (piece (signed-byte 8) 0)
	 (from-sqr (signed-byte 8) 0)
	 (to-sqr (signed-byte 8) 0)
	 (best-from (signed-byte 8) 0)
	 (best-to (signed-byte 8) 0)
	 (capt-sqr (signed-byte 8) 0)
	 (start-sqr (signed-byte 8) 0)
	 (hash hash-entry))
	(loop while (progn 
		      (setf h (hash-entry-key (aref *table* (incf j))))
		      (and (/= h 0) 
			   (/= (- h key-hi) 0)
			   (/= (decf i) 0))))
	(setf hash (aref *table* (if (/= i 0) j 0)))
	(if (/= 0 (hash-entry-key hash))
	    (progn 
	      (setf iter-depth (hash-entry-draft hash))
	      (setf score (hash-entry-score hash))
	      (setf best-from (hash-entry-from hash))
	      (if (>= iter-depth depth)
		  (if (and (>= score (logand (logior beta best-from) 128))
			   (<= score (logand (logior alpha best-from) 8)))
		      (return-from search score))
		  (setf iter-depth (- depth 1)))
	      (setf best-from (logand best-from (lognot 136)))
	      (setf best-to (hash-entry-to hash))
	      (setf best-to (if (=/ iter-depth 0) best-to 0)))
	    (progn
	      (setf iter-depth 0)
	      (setf best-from 0)
	      (setf best-to 0)))
	(incf nodes)
	
	
))
	 
